-- ======================
-- TABLE: customers
-- ======================
CREATE TABLE public.customers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policy: SELECT for authenticated users
CREATE POLICY "Enable select for authenticated users only"
  ON public.customers
  FOR SELECT
  TO authenticated
  USING (true);

-- ======================
-- TABLE: delivery_methods
-- ======================
CREATE TABLE public.delivery_methods (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.delivery_methods ENABLE ROW LEVEL SECURITY;

-- Policy: SELECT for authenticated users
CREATE POLICY "Enable select for authenticated users only"
  ON public.delivery_methods
  FOR SELECT
  TO authenticated
  USING (true);

-- ======================
-- TABLE: order_statuses
-- ======================
CREATE TABLE public.order_statuses (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.order_statuses ENABLE ROW LEVEL SECURITY;

-- Policy: SELECT for authenticated users
CREATE POLICY "Enable select for authenticated users only"
  ON public.order_statuses
  FOR SELECT
  TO authenticated
  USING (true);

-- ======================
-- TABLE: payment_methods
-- ======================
CREATE TABLE public.payment_methods (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.payment_methods ENABLE ROW LEVEL SECURITY;

-- Policy: SELECT for authenticated users
CREATE POLICY "Enable select for authenticated users only"
  ON public.payment_methods
  FOR SELECT
  TO authenticated
  USING (true);

-- ======================
-- TABLE: profiles
-- ======================
CREATE TABLE public.profiles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL DEFAULT auth.uid(),
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  phone TEXT NOT NULL,
  secondary_phone TEXT,
  website TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  CONSTRAINT profiles_user_id_key UNIQUE (user_id),
  CONSTRAINT profiles_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE CASCADE
);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policy: SELECT (users see only their data)
CREATE POLICY "Enable users to view their own data only"
  ON public.profiles
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

-- Policy: INSERT (authenticated users)
CREATE POLICY "Enable insert for authenticated users only"
  ON public.profiles
  FOR INSERT
  TO authenticated
  WITH CHECK (true);

-- Policy: UPDATE (only owner can update)
CREATE POLICY "Enable update for users based on user_id"
  ON public.profiles
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Policy: DELETE (only owner can delete)
CREATE POLICY "Enable delete for users based on user_id"
  ON public.profiles
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

-- ======================
-- TABLE: orders
-- ======================
CREATE TABLE public.orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  total_price NUMERIC NOT NULL,
  user_id UUID NOT NULL DEFAULT auth.uid(),
  customer_id BIGINT NOT NULL,
  delivery_method_id BIGINT NOT NULL,
  payment_method_id BIGINT NOT NULL,
  order_status_id BIGINT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  CONSTRAINT orders_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customers (id) ON DELETE CASCADE,
  CONSTRAINT orders_payment_method_id_fkey FOREIGN KEY (payment_method_id) REFERENCES payment_methods (id) ON DELETE CASCADE,
  CONSTRAINT orders_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE CASCADE,
  CONSTRAINT orders_order_status_id_fkey FOREIGN KEY (order_status_id) REFERENCES order_statuses (id) ON DELETE CASCADE,
  CONSTRAINT orders_delivery_method_id_fkey FOREIGN KEY (delivery_method_id) REFERENCES delivery_methods (id) ON DELETE CASCADE
);

-- Enable RLS
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;

-- Policy: SELECT only their own orders
CREATE POLICY "Enable select for users based on user_id"
  ON public.orders
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- ======================
-- FUNCTION: handle_new_user
-- Inserts a row into public.profiles
-- ======================
CREATE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (
    user_id, first_name, last_name, phone, secondary_phone, website
  )
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data ->> 'first_name', ''),
    COALESCE(NEW.raw_user_meta_data ->> 'last_name', ''),
    COALESCE(NEW.raw_user_meta_data ->> 'phone', ''),
    COALESCE(NEW.raw_user_meta_data ->> 'secondary_phone', ''),
    COALESCE(NEW.raw_user_meta_data ->> 'website', '')
  );
  RETURN NEW;
END;
$$;

-- ======================
-- FUNCTION: get_orders
-- Gets the orders, allows filtering by order_status_id, and sort by any field
-- ======================
CREATE OR REPLACE FUNCTION get_orders(
  p_order_by TEXT DEFAULT 'created_at',
  p_order_direction TEXT DEFAULT 'desc',
  p_status_filter INT DEFAULT NULL,
  p_offset INT DEFAULT 0,
  p_limit INT DEFAULT 10
)
RETURNS TABLE (
  id BIGINT,
  total_price NUMERIC,
  date DATE,
  hour TIME,
  customer TEXT,
  delivery_method TEXT,
  payment_method TEXT,
  order_status TEXT,
  created_at TIMESTAMP WITH TIME ZONE
) AS $$
DECLARE
  sql TEXT;
BEGIN
  sql := '
    SELECT
      T1.id,
      T1.total_price,
      CAST(T1.created_at AS DATE) AS date,
      CAST(T1.created_at AS TIME) AS hour,
      T2.first_name || '' '' || T2.last_name AS customer,
      T3.name AS delivery_method,
      T4.name AS payment_method,
      T5.name AS order_status,
      T1.created_at
    FROM orders T1
    JOIN customers T2 ON T1.customer_id = T2.id
    JOIN delivery_methods T3 ON T1.delivery_method_id = T3.id
    JOIN payment_methods T4 ON T1.payment_method_id = T4.id
    JOIN order_statuses T5 ON T1.order_status_id = T5.id
    WHERE ( $1 IS NULL OR T1.order_status_id = $1 )
    ORDER BY ';

  -- Solo permitimos ciertos campos para evitar SQL Injection
  IF p_order_by = 'created_at' THEN
    sql := sql || 'T1.created_at';
  ELSIF p_order_by = 'date' THEN
    sql := sql || 'CAST(T1.created_at AS DATE)';
  ELSIF p_order_by = 'time' THEN
    sql := sql || 'CAST(T1.created_at AS TIME)';
  ELSIF p_order_by = 'customer' THEN
    sql := sql || 'T2.first_name || '' '' || T2.last_name';
  ELSIF p_order_by = 'delivery_method' THEN
    sql := sql || 'T3.name';
  ELSIF p_order_by = 'payment_method' THEN
    sql := sql || 'T4.name';
  ELSIF p_order_by = 'order_status' THEN
    sql := sql || 'T5.name';
  ELSIF p_order_by = 'total_price' THEN
    sql := sql || 'T1.total_price';
  ELSIF p_order_by = 'id' THEN
    sql := sql || 'T1.id';
  ELSE
    sql := sql || 'T1.created_at';
  END IF;

  -- Dirección ASC o DESC, sólo permitimos esas dos opciones
  IF lower(p_order_direction) = 'asc' THEN
    sql := sql || ' ASC';
  ELSE
    sql := sql || ' DESC';
  END IF;

  sql := sql || ' OFFSET $2 LIMIT $3';

  RETURN QUERY EXECUTE sql
    USING p_status_filter, p_offset, p_limit;
END;
$$  LANGUAGE plpgsql STABLE;

-- ======================
-- TRIGGER: on_auth_user_created
-- Trigger the function every time a user is created
-- ======================
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
